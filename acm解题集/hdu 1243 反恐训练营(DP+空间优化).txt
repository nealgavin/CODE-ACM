反恐训练营

Time Limit: 2000/1000 MS (Java/Others)    Memory Limit: 65536/32768 K (Java/Others)
Total Submission(s): 2067    Accepted Submission(s): 454




Problem Description

当今国际反恐形势很严峻，特别是美国“9.11事件”以后，国际恐怖势力更是有恃无恐，制造了多起骇人听闻的恐怖事件。基于此，各国都十分担心恐怖势力会对本国社会造成的不稳定，于是纷纷在本国的军队、警察队伍中开展了反恐训练。作为反恐立场坚定的大国，中国也十分重视在人民解放军、武装警察部队、人民警察队伍中反恐训练，还专门成立了反恐特警队。

炜炜是反恐特警队的一名新队员，现在正在接受培训。这几天刚好是射击训练第二阶段――实弹应变训练的日子，此前的第一阶段里，炜炜经过努力，已经将自己训练成为一个百发百中的神抢手了！这次，他将背着国产最新型12.7mm重型狙击枪进行训练比赛。

这次训练比赛的规则是这样的：

1、每个队员从出发点开始，沿着一条唯一的笔直道路跑直到终点，途中不允许往回跑，否则将被取消比赛资格。
2、出发前，每个队员的枪膛内都被装了顺序一样的、用小写英文字母标明类型的子弹序列，每位队员被告知这一序列的信息；同时，每位队员也被告知恐怖分子即将出现的序列和类型（同样用小写英文字母标明类型）。
3、在跑动的过程中，若发现“恐怖分子”，特警队员可以选择用枪击毙他，来得到写在“恐怖分子”胸前的得分，但是前提是他使用的子弹类型必须和“恐怖分子”类型相同，否则，即使击毙了“恐怖分子”，也得不到分数；当然选择不击毙他也是可以的，这样他不会从那个“恐怖分子”身上得到分数。
4、允许特警队员放空枪，这样可以消耗掉型号不对的子弹而不至于杀死“恐怖分子”（当然每个特警队员都不会愚蠢到不装消音装置就放空枪，以至于吓跑“恐怖分子”），等待枪口出现正确型号的子弹击毙他得分。

这里，我们假定：
1、对于每个队员，途中出现恐怖分子的地点、时间、类型也是完全一样的。
2、每颗子弹都是质量合格的，都可以发挥杀伤效力
3、由于队员各个都是神枪手，一旦他选择了正确的子弹，向目标射击，目标100%被爆头
4、每个队员的记忆力超强，能记住所有子弹序列信息和恐怖分子序列信息。
5、每个队员体力足够好，能跑完全程，并做他想要做的
6、“恐怖分子”是不动的，小范围内不存在多于一个的恐怖分子；

炜炜需要你的帮助，告诉他如何做，才能得到最高的分数。现在如果告诉你出发时枪膛内子弹的序号和型号、恐怖分子出现的序号和类型，你能告诉炜炜他最多能得到多少分数吗？


 




Input

输入数据的第一行有一个整数N表示子弹和恐怖分子的类型数。随后的一行是各种恐怖分子类型的一行字母，两个字母之间没有任何字符。接下来的一行是击毙上一行对应位置恐怖分子类型的得分数，每个分数之间恰有一个空格。第三第四行分别表示开始时枪膛内子弹的序列（左边的先打出）和恐怖分子出现的序列（左边的先出现），字母之间都没有任何字符。
每个测试数据之间没有空格和空行。你的程序必须通过全部测试数据，才能被判为AC。


 




Output

对于每一个测试数据，输出炜炜最多能得到的分数。


 




Sample Input

3
abc
1 1 1
abc
ccc
3
abc
1 1 1
ccc
aba
 




Sample Output

1
0
 




Author

JGShining（极光炫影）

 




Recommend

Ignatius.L


思路：dp[x][y]表示前x个子弹，打前y个人的最大得分。

          如果第x个子弹对应第y个人。那么dp[x][y]=dp[x-1][y-1]+打他的分数。

         否则 dp[x][y]=max(dp[x][y-1],dp[x-1][y]);

正常开2二维空间不允许，所以需要优化下有滚动数组，一维空间。
///hdu 1243
#include<iostream>
#include<cstring>
using namespace std;
const int mm=4030;
char s[mm],ss[mm];
int vis[mm],have[mm];
int dp[2][mm];
int m;
int main()
{
  while(cin>>m)
  { memset(have,0,sizeof(have));
    memset(vis,0,sizeof(vis));
    memset(dp,0,sizeof(dp));
    cin>>s;
    for(int i=0;i<m;i++)
      cin>>have[s[i]];
    cin>>s>>ss;
    int s_len=strlen(s);
    int ss_len=strlen(ss);
    int v;
    for(int i=1;i<=s_len;i++)
    { v=i%2;
      for(int j=1;j<=ss_len;j++)
      {
        if(s[i-1]==ss[j-1])
          dp[v][j]=dp[v^1][j-1]+have[s[i-1]];
        else dp[v][j]=dp[v^1][j]>dp[v][j-1]?dp[v^1][j]:dp[v][j-1];
      }
    }
    cout<<dp[s_len%2][ss_len]<<"\n";
  }
}




