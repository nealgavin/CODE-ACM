取石子游戏
Time Limit: 1000MS	
Memory Limit: 10000K
Total Submissions: 29959	
Accepted: 9818
Description
有两堆石子，数量任意，可以不同。游戏开始由两个人轮流取石子。游戏规定，每次有两种不同的取法，一是可以在任意的一堆中取走任意多的石子；二是可以在两堆中同时取走相同数量的石子。最后把石子全部取完者为胜者。现在给出初始的两堆石子的数目，如果轮到你先取，假设双方都采取最好的策略，问最后你是胜者还是败者。
Input
输入包含若干行，表示若干种石子的初始情况，其中每一行包含两个非负整数a和b，表示两堆石子的数目，a和b都不大于1,000,000,000。
Output
输出对应也有若干行，每行包含一个数字1或0，如果最后你是胜者，则为1，反之，则为0。
Sample Input
2 1
8 4
4 7
Sample Output
0
1
0
Source
NOI

思路：
定理 0：一个状态是必败态，当且仅当它的所有后继状态都是必胜态；而一个状态是必胜态，只要它的后继状态有一个以上的必败态即可。
证明略去。
容易发现下面的定理：
定理 1：(a，b) 和 (b, a) 的胜负性是相同的（a <> b）。
证明：如果 (a, b) 是必胜态，那么将必胜策略中所有的操作，对第一堆的变为第二堆，对第二堆的变为第一堆，就构成 (b, a) 的必胜策略
定理 2：若 (a, b) 是必败态，则对于所有的 x <> a 和 y <> b，(x, b) 和 (a, y) 是必胜态。
证明：
对于 x > a 和 y > b，不管是哪一种情况，总可以从 x 堆或 y 堆中取出一定量的石子使当前状态变为必败态 (a, b)，由定理 1，(x, b) 和 (a, y) 为必胜态。
对于 x < a 和 y < b，不管是哪一种情况，如果 (x, b) 或 (a, y) 是必败态的话，由上述可得 (a, b) 是必胜态，矛盾。故 (x, b) 和 (a, y) 均为为必胜态。
定理 3: 若 (a, b) 是必败态，则对于所有的 d > 0，(a + d, b + d) 是必胜态。
证明：
与定理 2 类似。
定理 4：在所有的必败态中，每个数字恰巧出现一次。
证明：
 
有了定理 1，对于对称的状态我们只需要处理其中一个，而两个数不会相同（相同的状态必然是必胜态），于是我们把每个状态中较小的数字放在前面，每行写一个状态，去掉括号并按照升序排列每行的第一个数，就构成了如下的矩阵：
1  2
3  5
4  7
6  10
……
观察这个矩阵，我们又可以得到新的定理：
定理 5：矩阵中每行第一个数恰巧是前面每一行中没有出现过的最小正整数。
定理 6：矩阵第 i 行的第二个数正好为第一个数加上 i

定理 7（Betty 定理）：如果存在正无理数 A, B 满足 1/A + 1/B = 1，那么集合 P = { [At], t ∈ Z+}、Q = { [Bt], t ∈ Z+} 恰为集合 Z+ 的一个划分，即：P ∪ Q = Z+，P ∩ Q = 空。
证明：暂时略去，将来补充。
考虑到 Betty 定理中“恰为 Z+ 的划分”这一说，这意味着，Z+ 中的每个数都恰好出现一次，这与上述矩阵的性质十分吻合。于是我们猜想每一行第一列的数满足 [Φi] 的形式。
于是我们得到每一行第二列的数为 [Φi] + i = [Φi + i] = [(Φ + 1)i]
我们的目的是要让 Z+ 中每个数都在这个矩阵中出现，于是考虑到 Betty 定理的条件，Φ 和 (Φ + 1) 应满足 1/Φ + 1/(Φ + 1) = 1。解这个方程，我们得到 Φ = (sqrt(5) + 1) / 2，于是 Φ + 1 = (sqrt(5) + 3) / 2。
Φ 恰为黄金分割比，这是多么令人惊奇的结论！
于是应用 Betty 定理，我们得到最终我们需要的定理：
定理 8：上述矩阵中每一行第一列的数为 [Φi]，第二列的数为 [(Φ + 1)i]，其中 Φ = (sqrt(5) + 1) / 2 为黄金分割比。
证明：由 Betty 定理显然得证。

#include<iostream>
#include<cmath>
using namespace std;
int a,b;
int main()
{
  while(cin>>a>>b)
  {
    if(a>b)a^=b,b^=a,a^=b;
    b-=a;b=(int)b*((sqrt(5.0)+1.0)/2.0);
    if(b==a)cout<<0<<"\n";
    else cout<<1<<"\n";

  }
}



